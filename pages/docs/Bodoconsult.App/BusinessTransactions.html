<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Business transactions with IBusinessTransactionManager / BusinessTransactionManager | Bodoconsult.AppInfrastructure </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Business transactions with IBusinessTransactionManager / BusinessTransactionManager | Bodoconsult.AppInfrastructure ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Bodoconsult/Bodoconsult.AppInfrastructure/blob/main/docs/Bodoconsult.App/BusinessTransactions.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="Bodoconsult.AppInfrastructure">
            Bodoconsult.AppInfrastructure
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="business-transactions-with-ibusinesstransactionmanager--businesstransactionmanager">Business transactions with IBusinessTransactionManager / BusinessTransactionManager</h1>

<h2 id="overview">Overview</h2>
<p>A business transaction is defined here as an external call for a certain functionality of an app by a UI client, webservice or any other client of the app. BusinessTransactionManager class is intended as central point for inbound business transactions for the app. At least each external call via technologies like GRPC or Webservice should be a business transaction.</p>
<p>BusinessTransactionManager delivers central features like logging and performance measurement to external request to your app. So it helps to simplify external interface classes using technologies like GRPC, WebAPI or Webservice by keeping business logic out of them.</p>
<p>Imaging you have to develop an server app based on a database. The server app has a GUI and a separate webservice app connected via GRPC as transportation technology. The transportation layer is accessing directly the business logic layer.</p>
<p>With a well disciplined dev team this is no big deal. It maps the Protobuf DTO coming from GUI or webservice to an internal DTO and forwards it to the business logic.</p>
<p><img src="../../images/BusinessTransactions3.jpg" alt="App without business transactions"></p>
<p>The approach of accesing business logic directly from transportation layer will work well basically but has some drawbacks in every case:</p>
<ul>
<li>You have to implement a GRPC related method in the transportation for each separate request. This blows up the source code and is expensive for resssources like RAM</li>
<li>Request logging has to be done in each of this GRPC related request methods separately</li>
<li>Handling request meta data like ClientId or User has to be done in each of this GRPC related request methods separately</li>
<li>With an unexperienced dev team the danger of having transportation layer dependencies like GRPC spread all over the source code is growing</li>
<li>With an unexperienced dev team the danger of having buisness logic implemented directly in transportation layer is growing</li>
</ul>
<p><img src="../../images/BusinessTransactions2.jpg" alt="Potential trouble without business transactions"></p>
<p>All of the above points lead to uncessary source code to be maintained and shrinking testabililty up to untestability.</p>
<p>Using business transactions addresses all of the above points.</p>
<ul>
<li>You need only one GRPC method for receiving the business transaction request</li>
<li>Central handling of logging and basic error handling</li>
<li>Central handling of request meta data like ClientId or User</li>
<li>Clear separation of business logic layer and transportation layer</li>
<li>Lightweight implementation of the business transaction layer</li>
</ul>
<p><img src="../../images/BusinessTransactions1.jpg" alt="Business transactions: overview"></p>
<p>Business transaction can be used app internally too.</p>
<p>For short running business transactions the GRPC request can directly wait for an answer. This is a syncronous working behavior.</p>
<p>For longer running business transactions it is potentially possible to implement a back channel to the client or webservice via GRPC and provide the result of the business transaction with its unique ID. With this ID the receiver can handle the result correctly as it is possible to nake a relation between the original request and the late coming reply. This is an asyncronous working behavior.</p>
<h2 id="base-class-businesstransaction">Base class BusinessTransaction</h2>
<p>Base class for business transactions is the class BusinessTransaction with the main properties Id, Name and RunBusinessTransactionDelegate.</p>
<p>RunBusinessTransactionDelegate is the binding member from business transactions to the business logic.</p>
<pre><code class="lang-csharp">
/// &lt;summary&gt;
/// Represents a business transaction that can be called from a client the current app
/// &lt;/summary&gt;
public class BusinessTransaction
{
    /// &lt;summary&gt;
    /// A unique transaction ID. Transaction are called by this ID by the client
    /// &lt;/summary&gt;
    public int Id { get; set; }

    /// &lt;summary&gt;
    /// Name of the transaction
    /// &lt;/summary&gt;
    public string Name { get; set; }

    /// &lt;summary&gt;
    /// Error code the transaction should return. Default: 0 means no error 
    /// &lt;/summary&gt;
    public int ErrorCode { get; set; } = 0;

    /// &lt;summary&gt;
    /// The error message the transaction should return
    /// &lt;/summary&gt;
    public string ErrorMessage { get; set; }

    /// &lt;summary&gt;
    /// The business logic method that should be called for the current transaction
    /// &lt;/summary&gt;
    public RunBusinessTransactionDelegate RunBusinessTransactionDelegate { get; set; }

    /// &lt;summary&gt;
    /// Do not add an event counter for this transaction
    /// &lt;/summary&gt;
    public bool NoEventCounter { get; set; } = false;

}

</code></pre>
<h2 id="sample-implementation-of-a-business-transaction-provider">Sample implementation of a business transaction provider</h2>
<p>An app using the business transactions should define a set of IBusinessTransactionProvider based classes providing the logic for the required business transactions.
This set of providers has to be loaded once  with the method AddProvider() to the BusinessTransActionManager class on app start.</p>
<p>After usage the IBusinessTransactionProvider implementations are removed from memory. Only the transactions loaded stay in the memory.</p>
<pre><code class="lang-csharp">
internal class TestBusinessTransactionProvider: IBusinessTransactionProvider
{

    /// &lt;summary&gt;
    /// Default ctor
    /// &lt;/summary&gt;
    public TestBusinessTransactionProvider(SampleBusinessLogicLayer sampleBusinessLogicLayer)
    {
        SampleBusinessLogic = sampleBusinessLogicLayer;

        CreateBusinessTransactionDelegates.Add(1000, CreateTnr1000);
    }

    /// &lt;summary&gt;
    /// A dictionary containing delegates for creating business transactions.
    /// The key of the dictionary is the int tarnsaction ID
    /// &lt;/summary&gt;
    public Dictionary&lt;int, CreateBusinessTransactionDelegate&gt; CreateBusinessTransactionDelegates { get; } = new();

    /// &lt;summary&gt;
    /// Business logic dependency
    /// &lt;/summary&gt;
    public SampleBusinessLogicLayer SampleBusinessLogic { get; } 

    /// &lt;summary&gt;
    /// Create business transcation 1000. Public for unit testing. Do not use directly in production
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Business transaction&lt;/returns&gt;
    public BusinessTransaction CreateTnr1000()
    {
        var bt =  new BusinessTransaction
        {
            Id = 1000,
            Name = &quot;Testtransaction&quot;,
            RunBusinessTransactionDelegate = SampleBusinessLogic.EmptyRequest
        };

        bt.AllowedRequestDataTypes.Add(nameof(EmptyBusinessTransactionRequestData));

        return bt;
    }
}

</code></pre>
<p>Add a unit tests for the provider. See typical examples here:</p>
<pre><code class="lang-csharp">
/// &lt;summary&gt;
/// Helper method to set up provider. May require mocking of dependencies
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private static TestBusinessTransactionProvider CreateProvider()
{
    var dependency = new SampleBusinessLogicLayer();
    var prov = new TestBusinessTransactionProvider(dependency);
    return prov;
}

[Test]
public void CheckAll_ValidSetup_Success()
{
    // Arrange 
    var prov = CreateProvider();

    // Act  
    foreach (var item in prov.CreateBusinessTransactionDelegates)
    {

        var transaction = item.Value.Invoke();

        Assert.That(item.Key, Is.EqualTo(transaction.Id));

    }
}

[Test]
public void CreateBusinessTransactionDelegates_DefaultSetup_ReturnsTransaction()
{
    // Arrange 
    const int tnr = 1000;

    var prov = CreateProvider();

    // Act  
    prov.CreateBusinessTransactionDelegates.TryGetValue(tnr, out var test);
    prov = null; // Kill the provider to see if the static delegate method is called correctly

    // Assert
    Assert.That(test, Is.Not.Null);

    var result = test.Invoke();

    Assert.That(result, Is.Not.Null);

}

[Test]
public void Ctor_ValidSetup_Success()
{
    // Arrange
    var dependency = new SampleBusinessLogicLayer();
    // Act
    var prov = new TestBusinessTransactionProvider(dependency);

    // Assert
    Assert.That(prov.SampleBusinessLogic, Is.Not.Null);
    Assert.That(prov.SampleBusinessLogic, Is.SameAs(dependency));
}

[Test]
public void Transaction1000_TestTransaction_ValidSetup_Success()
{
    // Arrange 
    var prov = CreateProvider();

    // Act  
    var result = prov.CreateTnr1000();

    // Assert
    Assert.That(result, Is.Not.Null);
    Assert.That(result.Id, Is.EqualTo(1000));
    Assert.That(result.RunBusinessTransactionDelegate, Is.Not.Null);
    Assert.That(result.AllowedRequestDataTypes.Count, Is.Not.EqualTo(0));
}

</code></pre>
<p>Here a simple example how to set up and to use the business transactions:</p>
<pre><code class="lang-csharp">
// Arrange 
var aes = TestHelper.CreateAppEventSource();

const int transactionId = 1000;
var m = new BusinessTransactionManager(_logger, aes);
var p = new TestTransactionProvider();

m.AddProvider(p);

IBusinessTransactionRequestData requestData = new EmptyBusinessTransactionRequestData();

// Act  
var t = m.RunBusinessTransaction(transactionId, requestData);

// Assert
Assert.That(t, Is.Not.Null);
Assert.That(m.TransactionCache, Has.Count.EqualTo(1));
Assert.That(t.RequestData, Is.EqualTo(requestData));

</code></pre>
<h2 id="sample-implementation-of-a-business-transaction-loader-handling-multiple-business-transaction-providers">Sample implementation of a business transaction loader handling multiple business transaction providers</h2>
<p>If you have multiple providers for business transactions you should implement IBusinessTransactionLoader. It allows easier handling of multiple espacially if using a DI container.</p>
<p>After usage the IBusinessTransactionLoader and IBusinessTransactionProvider implementations are removed from memory. Only the transactions loaded stay in the memory.</p>
<pre><code class="lang-csharp">
internal class TestBusinessTransactionLoader: IBusinessTransactionLoader
{
    /// &lt;summary&gt;
    /// Default ctor
    /// &lt;/summary&gt;
    public TestBusinessTransactionLoader(IBusinessTransactionManager businessTransactionManager, SampleBusinessLogicLayer sampleBusinessLogicLayer)
    {
        BusinessTransactionManager = businessTransactionManager;
        SampleBusinessLogic = sampleBusinessLogicLayer;
    }

    /// &lt;summary&gt;
    /// Current &lt;see cref=&quot;IBusinessTransactionManager&quot;/&gt; impl to load the providers in
    /// &lt;/summary&gt;
    public IBusinessTransactionManager BusinessTransactionManager { get; }

    /// &lt;summary&gt;
    /// Business logic dependency
    /// &lt;/summary&gt;
    public SampleBusinessLogicLayer SampleBusinessLogic { get; }

    /// &lt;summary&gt;
    /// Load the providers
    /// &lt;/summary&gt;
    public void LoadProviders()
    {
        var provider = new TestBusinessTransactionProvider(SampleBusinessLogic);
        BusinessTransactionManager.AddProvider(provider);

        // Add more providers
    }
}

</code></pre>
<p>Here an example how to use the IBusinessTransactionLoader instance:</p>
<pre><code class="lang-csharp">
// Arrange 
var aes = TestHelper.CreateAppEventSource();
var logger = TestHelper.GetFakeAppLoggerProxy();

const int transactionId = 1000;
var m = new BusinessTransactionManager(logger, aes);

var dependency = new SampleBusinessLogicLayer();
var p = new TestBusinessTransactionLoader(m, dependency);

p.LoadProviders();

IBusinessTransactionRequestData requestData = new EmptyBusinessTransactionRequestData();

// Act  
var t = m.RunBusinessTransaction(transactionId, requestData);

// Assert
Assert.That(t, Is.Not.Null);
Assert.That(m.TransactionCache, Has.Count.EqualTo(1));
Assert.That(t.RequestData, Is.EqualTo(requestData));

</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Bodoconsult/Bodoconsult.AppInfrastructure/blob/main/docs/Bodoconsult.App/BusinessTransactions.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
